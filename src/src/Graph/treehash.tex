\begin{small}
无根树哈希：以重心为根，如果重心有两个，分别判断即可。
有根树哈希：

\subsubsection{方法一}  
按照 dfs 序可以将树上结点对应到序列上，在序列上填上对应结点的深度，根据序列可以还原出形态唯一的树，那么树哈希便转换成了序列上的哈希。  
递归处理：初始 $hash(u)=dep_u$ ，插入 $v$ 子树，就相当于两个序列接起来，$hash(u)'=hash(u)\times base^{siz_v}+hash(v)$ 。  
如果交换子树的顺序算同构，把 $u$ 所有孩子的哈希值排序后再加入；  
如果要判断两个不同深度的子树是否同构，把深度换成高度（到最深叶子结点的距离）。  

\subsubsection{方法二}
按照以下公式：

\[
f_{u}=c+\sum_{v\in son(u)} f_{v}\times prime(size_{v})
\]

其中 $f_u$ 表以 $u$ 为根子树对应的哈希值。$size_v$ 表 $v$ 子树大小，$son(u)$ 为 $u$ 点孩子的集合，$prime(i)$ 为第 $i$ 个质数， $c$ 随便搞个常数。

\end{small}